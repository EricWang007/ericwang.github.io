<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm&amp;DataStructure on EricWang's Blog</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/</link><description>Recent content in Algorithm&amp;DataStructure on EricWang's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 22 Sep 2021 06:00:20 +0600</lastBuildDate><atom:link href="https://ericwang007.github.io/posts/algorithmdatastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>红黑树</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Wed, 22 Sep 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>红黑树 性质 是一种特殊的**二叉查找树**（任意节点的左子树上的节点小于该节点，右子树上的节点大于该节点） 每个节点都是红色或黑色 每个叶子节点的子节点（NULL节点）为黑色 红色节点的子节点都是黑色 从一个结点到其所有的后代叶子结点的路径上包含的黑色结点数量相同。 性质5确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。
应用 主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。
例如：
Java集合中的TreeSet和TreeMap C++ STL中的set、map Linux虚拟内存的管理 基本操作 左旋&amp;amp;右旋 添加 将红黑树当作一颗二叉查找树，将节点插入，着色为红色。
由于可能违背了性质4，故需要调整。分三种情况：
叔叔是红色
叔叔是黑色，且当前节点是右孩子
叔叔是黑色，且当前节点是左孩子
删除</description></item><item><title>排序方法总结</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 27 Aug 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>排序方法总结 排序方法 时间复杂度（平均） 时间复杂度（最好） 时间复杂度（最坏） 空间复杂度 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(nlogn) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n^2) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 冒泡排序 依次比较相邻元素，并把大数向后交换，比完一轮后最大的数换到了最后。
重复以上步骤，将第二大的元素放到倒数第二位&amp;hellip;
插入排序 对于未排序元素，在已排序序列中从后向前扫描，找到相应位置并插入。
void merger_sort(Type A[], int left, int right) { if(left &amp;lt; right) { int middle = (left+right)/2; merger_sort(A, left, middle); merger_sort(A, middle, right); merge(A, B, left, middle, right);//合并到数组B copy(A, B, left, right);//复制回数组A } } void merge(Type A[], Type B, int left, int middle, int right) { int i = left, j = middle+1, k=1; while((i &amp;lt; middle) &amp;amp;&amp;amp; (j &amp;lt;= right)) { if(c[i] &amp;lt;= c[j]) d[k++] = c[i++]; else d[k++] = c[j++]; } if(i &amp;gt; middle) { for(int q = j; q &amp;lt; m; q++) d[k++] = c[q]; } else { for(int q = i; q &amp;lt;= m; q++) d[k++] = c[q]; } } 快速排序 从数列中挑一个元素，作为“基准”(pivot)。</description></item><item><title>最小生成树</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link><pubDate>Fri, 27 Aug 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid><description>最小生成树 class Graph { public int vertexs; // 顶点个数 public char[] data; // 顶点标识 public int[][] weight; // 邻接矩阵（边的权值） public int edg_num; // 边的条数 public Graph(int vertexs, char[] data, int[][] weight) { if (vertexs != data.length || weight.length != vertexs || weight[0].length != vertexs) { throw new RuntimeException(&amp;#34;初始化异常！&amp;#34;); } this.vertexs = vertexs; this.data = data; this.weight = weight; } } Prime算法 public class Prime { final static int MAX = Integer.</description></item></channel></rss>