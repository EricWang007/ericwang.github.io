<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm&amp;DataStructure on EricWang's Blog</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/</link><description>Recent content in Algorithm&amp;DataStructure on EricWang's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 27 Aug 2021 06:00:20 +0600</lastBuildDate><atom:link href="https://ericwang007.github.io/posts/algorithmdatastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>排序方法总结</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 27 Aug 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>排序方法总结 排序方法 时间复杂度（平均） 时间复杂度（最好） 时间复杂度（最坏） 空间复杂度 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(nlogn) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n^2) 稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 冒泡排序 依次比较相邻元素，并把大数向后交换，比完一轮后最大的数换到了最后。
重复以上步骤，将第二大的元素放到倒数第二位&amp;hellip;
插入排序 对于未排序元素，在已排序序列中从后向前扫描，找到相应位置并插入。
void merger_sort(Type A[], int left, int right) { if(left &amp;lt; right) { int middle = (left+right)/2; merger_sort(A, left, middle); merger_sort(A, middle, right); merge(A, B, left, middle, right);//合并到数组B copy(A, B, left, right);//复制回数组A } } void merge(Type A[], Type B, int left, int middle, int right) { int i = left, j = middle+1, k=1; while((i &amp;lt; middle) &amp;amp;&amp;amp; (j &amp;lt;= right)) { if(c[i] &amp;lt;= c[j]) d[k++] = c[i++]; else d[k++] = c[j++]; } if(i &amp;gt; middle) { for(int q = j; q &amp;lt; m; q++) d[k++] = c[q]; } else { for(int q = i; q &amp;lt;= m; q++) d[k++] = c[q]; } } 快速排序 从数列中挑一个元素，作为“基准”(pivot)。</description></item><item><title>最小生成树</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link><pubDate>Fri, 27 Aug 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid><description>最小生成树 class Graph { public int vertexs; // 顶点个数 public char[] data; // 顶点标识 public int[][] weight; // 邻接矩阵（边的权值） public int edg_num; // 边的条数 public Graph(int vertexs, char[] data, int[][] weight) { if (vertexs != data.length || weight.length != vertexs || weight[0].length != vertexs) { throw new RuntimeException(&amp;#34;初始化异常！&amp;#34;); } this.vertexs = vertexs; this.data = data; this.weight = weight; } } Prime算法 public class Prime { final static int MAX = Integer.</description></item><item><title>红黑树</title><link>https://ericwang007.github.io/posts/algorithmdatastructure/%E7%BA%A2%E9%BB%91%E6%A0%91/</link><pubDate>Fri, 27 Aug 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/algorithmdatastructure/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid><description>红黑树</description></item></channel></rss>