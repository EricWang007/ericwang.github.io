<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OS on EricWang's Blog</title><link>https://ericwang007.github.io/posts/os/</link><description>Recent content in OS on EricWang's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 03 Sep 2021 06:00:20 +0600</lastBuildDate><atom:link href="https://ericwang007.github.io/posts/os/index.xml" rel="self" type="application/rss+xml"/><item><title>知识梳理 2</title><link>https://ericwang007.github.io/posts/os/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-2/</link><pubDate>Fri, 03 Sep 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/os/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-2/</guid><description>知识梳理 2 4 CPU调度 基本概念 CPU调度：在主存中选择运行实体（ready queue中的进程/线程），并将CPU分配给它。在内核状态下选择、分配、激活。
进程执行周期：CPU burst + I/O burst CPU burst：进程在 running state I/O burst：进程在 waiting state 进程调度需要以下两个部件： 短期调度程序（short-term scheduler） 分派程序（dispatcher）：将CPU分配给短期调度程序选择的进程，功能包括 进程上下文切换 转到user mode 跳到用户程序的合适位置重新开始执行 上图中的t0-t3为派遣时延（dispatch latency）
调度什么时候出现：（1,2为非抢占式，3,4为抢占式）
进程终止 运行的进程转为waiting状态（e.g., 进程主动I/O requests，或调用wait等待子进程终止） 运行的进程转为ready状态（e.g.，中断出现，或时间戳结束） waiting-&amp;gt;ready（e.g.，I/O完成） 调度准则 调度算法</description></item><item><title>知识梳理 1</title><link>https://ericwang007.github.io/posts/os/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-1/</link><pubDate>Thu, 02 Sep 2021 06:00:20 +0600</pubDate><guid>https://ericwang007.github.io/posts/os/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-1/</guid><description>知识梳理 1 1 Introduction 计算机启动过程 BIOS -&amp;gt; MBR -&amp;gt; boot loader -&amp;gt; kernel -&amp;gt; init process
当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。 下一步，计算机将从你所选择的存储设备中读取起始的512 bytes。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。 随后，boot loader将kernel加载到内存中。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。 kernel开始加载第一个进程，例如&amp;quot;init&amp;quot;，并等待事件的出现。 事件 中断（interrupt/trap）：由硬件或外设触发，通过系统总线发一个信号给CPU，一般为异步方式。 中断会有一个中断ID。 程序会保存中断发生前一时刻的执行现场（保存一些寄存器中的值），然后去转到中断的服务例程执行中断。 中断完毕后，OS再恢复之前保存的处理状态，故中断是对应用程序透明的。 如：read系统调用后，系统发出读磁盘的操作，当磁盘数据准备好后，向OS发出一个异步通知消息。 异常（exception）：由应用程序触发，一般为同步方式。 异常也有异常编号ID，也会保存现场。 如：除0异常，无效地址访问 系统调用（system call）：由应用程序触发，应用程序向OS请求某个服务，异步或同步。 大多由应用程序通过API调用，而非直接由系统调用 存储结构 I/O 结构 每个设备控制器控制一种设备，负责控制数据在它自己的本地缓存和外部设备中的移动。 OS 为每个设备控制器分配了一个设备驱动器。 DMA（Direct Memory Access）——用于大块数据的移动</description></item></channel></rss>