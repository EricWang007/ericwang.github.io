---

title: "知识梳理 1"
date: 2021-09-02T06:00:20+06:00
hero: /images/posts/writing-posts/hugo-logo.svg
math: true
menu:
  sidebar:
    name: 知识梳理 1
    identifier: 知识梳理 1
    parent: OS
    weight: 10
---

# 知识梳理 1

---

## 1 Introduction

### 计算机启动过程

>  BIOS -> MBR -> boot loader -> kernel -> init process

* 当我们打开计算机电源，计算机会自动从主板的BIOS(Basic Input/Output System)读取其中所存储的程序。这一程序通常知道一些直接连接在主板上的硬件(硬盘，网络接口，键盘，串口，并口)。现在大部分的BIOS允许你从软盘、光盘或者硬盘中选择一个来启动计算机。
* 下一步，计算机将从你所选择的存储设备中读取起始的512 bytes。这512 bytes叫做主引导记录MBR (master boot record)。MBR会告诉电脑从该设备的某一个分区(partition)来装载引导加载程序(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。
* 随后，boot loader将kernel加载到内存中。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。
* kernel开始加载第一个进程，例如"init"，并等待事件的出现。

### 事件

* **中断（interrupt/trap）**：由硬件或外设触发，通过系统总线发一个信号给CPU，一般为异步方式。
  * 中断会有一个中断ID。
  * 程序会保存中断发生前一时刻的执行现场（保存一些寄存器中的值），然后去转到中断的服务例程执行中断。
  * 中断完毕后，OS再恢复之前保存的处理状态，故中断是对应用程序`透明的`。
  * 如：read系统调用后，系统发出读磁盘的操作，当磁盘数据准备好后，向OS发出一个异步通知消息。
* **异常（exception）**：由应用程序触发，一般为同步方式。
  * 异常也有异常编号ID，也会保存现场。
  * 如：除0异常，无效地址访问
* **系统调用（system call）**：由应用程序触发，应用程序向OS请求某个服务，异步或同步。
  * 大多由应用程序通过API调用，而非直接由系统调用
  * 

### 存储结构

![image-20210902111411270](/images/posts/OS/image-20210902111411270.png)

### I/O 结构

* 每个**设备控制器**控制一种设备，负责控制数据在它自己的本地缓存和外部设备中的移动。
* OS 为每个设备控制器分配了一个**设备驱动器**。

**DMA（Direct Memory Access）**——用于大块数据的移动

* 设备控制器直接将一整块数据在它的缓冲区和内存中移动，<u>不需要CPU的干预</u>。
* 每一块只会产生一个中断（告知设备驱动器）

![image-20210902113020518](/images/posts/OS/image-20210902113020518.png)

### User Mode & Kernel Mode

* **用户态**：CPU无法执行一下特权指令
* **内核态**：CPU可以执行特权指令

## 2 进程

### 进程状态

![image-20210902145732512](/images/posts/OS/image-20210902145732512.png)

* New: 进程被创建
* Ready：进程等待被分配给一个处理器
* Running：正在执行
* Waiting：进程等待某个事件（如I/O完成或信号接收
* Terminated：进程执行完毕

### 进程控制块 (PCB Process Control Block)

在OS中，每个进程由一个PCB表示。它包括：

* 进程状态
* 程序计数器
* CPU寄存器
* CPU调度信息
* 。。。

### 进程调度

* job queue: 等待某一特定I/O设备的进程的链表
* ready queue：处于ready状态的进程的链表

![image-20210902154305778](/images/posts/OS/image-20210902154305778.png)

![image-20210902154320105](/images/posts/OS/image-20210902154320105.png)

* 调度器（Scheduler）：
  * 长期调度（job scheduler）：从任务池（辅存）里挑选进程，送入ready queue（内存）。
  * 短期调度（CPU scheduler）：从ready queue中选择分配给CPU执行的进程。
  * 中期调度：将进程从内存或从CPU竞争中移出，从而<u>降低多道程序设计的程度</u>，之后进程能被重新调入内存，并从中断处继续执行。

当CPU转到另一个进程时，系统需要保存旧进程的状态，并通过contex switch（上下文切换）导入新进程的状态。

### 对进程的操作

>  进程由进程标识符（pid）标识。

* 在UNIX系统中，一个新进程通过fork()系统调用创建。新进程拥有原进程的地址空间。
* fork()的返回值：
  * 子进程：0
  * 父进程：子进程的pid
* exec()系统调用由两个进程之一调用，用于将进程的内存空间替换为一个新的程序。
* 父进程可以通过abort()终止子进程。

![image-20210902194609024](/images/posts/OS/image-20210902194609024.png)

### 进程间通信

两种基本模型：

* 共享内存：生产者-消费者问题
* 消息传递

## 3 线程

线程包括：线程ID、程序计数器、寄存器集、栈

* 多线程之间共享：代码段、数据段、其它OS资源（如打开的文件和信号）

![image-20210903105609541](/images/posts/OS/image-20210903105609541.png)

### 多线程模型

* 用户线程：由OS直接管理，位于内核之上
* 内核线程

三种模型：

* 多对一：一个内核线程阻塞导致全部用户线程阻塞
* 一对一：线程总数受限
* 多对多：运行OS创造足够数量的内核线程





