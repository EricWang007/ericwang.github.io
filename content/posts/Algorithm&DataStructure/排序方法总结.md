---
title: "排序方法总结"
date: 2021-07-27T06:00:20+06:00
hero: /writing-posts/hugo-logo.svg
menu:
  sidebar:
    name: 排序方法总结
    identifier: 排序方法总结
    parent: Algorithm&DataStructure
    weight: 10
---

# 排序方法总结

---

| 排序方法 | 时间复杂度（平均） | 时间复杂度（最好） | 时间复杂度（最坏） | 空间复杂度 |   稳定性   |
| :------: | :----------------: | :----------------: | :----------------: | :--------: | :--------: |
| 冒泡排序 |       O(n^2)       |        O(n)        |       O(n^2)       |    O(1)    |    稳定    |
| 插入排序 |       O(n^2)       |        O(n)        |       O(n^2)       |    O(1)    |    稳定    |
| 快速排序 |      O(nlogn)      |      O(nlogn)      |       O(n^2)       |  O(nlogn)  | **不稳定** |
| 归并排序 |      O(nlogn)      |      O(nlogn)      |      O(nlogn)      |   O(n^2)   |    稳定    |
|  堆排序  |      O(nlogn)      |      O(nlogn)      |      O(nlogn)      |    O(1)    | **不稳定** |
|          |                    |                    |                    |            |            |
|          |                    |                    |                    |            |            |
|          |                    |                    |                    |            |            |

## 冒泡排序

> 依次比较相邻元素，并把大数向后交换，比完一轮后最大的数换到了最后。
>
> 重复以上步骤，将第二大的元素放到倒数第二位...



## 插入排序

> 对于未排序元素，在已排序序列中从后向前扫描，找到相应位置并插入。



## 快速排序

> 从数列中挑一个元素，作为“基准”(pivot)。
>
> 将比基准小的元素放在基准前面，比基准大的元素放在基准后面。
>
> 递归地对两个子序列进行快排。

```c++
int partition(int num[], int left, int right) {
    int x = num[right];
    int i = left;
    int j = left - 1;
    for (; i < right; i++) {
        if (num[i] < x) {
            j++;
            if (j != i)
                swap(num[j], num[i]);
        }
    }
    swap(num[j + 1], num[right]);
    return j + 1;  //返回分割点
}

void quick_sort(int num[], int left, int right) {
    if (left < right) {
        int index = partition(num, left, right);
        quick_sort(num, left, index - 1);
        quick_sort(num, index + 1, right);
    }
}
```

快速排序的稳定版（Java，使用额外空间）：

```java
public int[] quickSort(int[] num) {
    ArrayList<Integer> ar = new ArrayList<>();
    for (int i : num) ar.add(i);
    ArrayList<Integer> ans = quickSort(ar);
    for (int i = 0; i < num.length; i++)
        num[i] = ans.get(i);
    return num;
}
public static ArrayList<Integer> quickSort(ArrayList<Integer> ar) {
    if(ar.size() <= 1) return ar;

    int mid = ar.size() / 2;
    int pivat = ar.get(mid);

    ArrayList<Integer> smaller = new ArrayList<>();
    ArrayList<Integer> greater = new ArrayList<>();
    for(int ind = 0; ind < ar.size(); ind++) {
        int val = ar.get(ind);
        if( ind != mid ) {
            if( val < pivat ) smaller.add(val);
            else if(val > pivat) greater.add(val);
            else {                   
                if(ind < mid) smaller.add(val);
                else greater.add(val);
            }
        }
    }
    ArrayList<Integer> ans = new ArrayList<Integer>();              
    ArrayList<Integer> sa1 = quickSort(smaller);
    ArrayList<Integer> sa2 = quickSort(greater);

    for(Integer val1 : sa1)  ans.add(val1);  
    ans.add(pivat);
    for(Integer val2 : sa2)  ans.add(val2);

    return ans;        
    }
```



## 归并排序

> 分治法。将两个已经排序的序列合并。

```c++
void merge_sort(int num[], int first, int end) {
    if (first < end) {
        int mid = (first + end) / 2;
        merge_sort(num, first, mid);
        merge_sort(num, mid + 1, end);
        merge(num, first, mid, end);
    }
}

void merge(int num[], int first, int mid, int end) {
    int n1 = mid - first + 1;
    int n2 = end - mid;
    int* L = new int[n1];
    int* R = new int[n2];
    for(int i = 0; i < n1; i++)
        L[i] = num[first + i];

    for (int j = 0; j < n2; j++)
        R[j] = num[mid + j + 1];

    int i = 0;
    int j = 0;
    int k = first;
    while(i < n1 && j < n2) {
        if (L[i] < R[j])
            num[k++] = L[i++];
        else
            num[k++] = R[j++];
    }

    while (i < n1) num[k++] = L[i++];
    while (j < n2) num[k++] = R[j++];
    
    delete [] L;
    delete [] R;
}
```

## 堆排序

> **堆**本质上是一个**数组**，且我们以**二叉树**的角度来看待他。

<img src=" /Algorithm&DataStructure/image-20210827161426717.png" alt="image-20210827161426717" style="zoom:70%;" />

<img src="../../../static/Algorithm&DataStructure/image-20210827161442509.png" alt="image-20210827161442509" style="zoom:70%;" />

* 左子结点的编号=父结点编号 * 2 
* 右子结点的编号=父结点编号 * 2 + 1

